//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use sea_orm::entity::prelude::*;
use sea_orm::sea_query::OnConflict;
use sea_orm::Set;

use crate::registry::Digest;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "tag")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub tag: String,
    #[sea_orm(primary_key, auto_increment = false)]
    pub repo: String,
    pub manifest_digest: Digest,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::repo_blob_association::Entity",
        from = "(Column::Repo, Column::ManifestDigest)",
        to = "(super::repo_blob_association::Column::RepoName, super::repo_blob_association::Column::BlobDigest)",
        on_update = "NoAction",
        on_delete = "Cascade"
    )]
    RepoBlobAssociation,
}

impl Related<super::repo_blob_association::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RepoBlobAssociation.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub async fn insert_or_update(
    tag: String,
    repo: String,
    manifest_digest: Digest,
    db: &impl ConnectionTrait,
) -> std::result::Result<sea_orm::InsertResult<ActiveModel>, sea_orm::DbErr> {
    Entity::insert(ActiveModel {
        tag: Set(tag),
        repo: Set(repo),
        manifest_digest: Set(manifest_digest),
    })
    .on_conflict(
        OnConflict::columns([Column::Tag, Column::Repo])
            .update_column(Column::ManifestDigest)
            .to_owned(),
    )
    .exec(db)
    .await
}
